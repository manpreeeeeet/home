---
title: deploying ktor application in a vps
---
import { Image } from 'astro:assets';
import githubActionImage from '../assets/github-action.png';


# Deploying Ktor app in a VPS using github actions
<div class="h-1 w-full my-4 bg-slate-800"></div>

## Overview
This is my simple docker + VPS setup for deploying Ktor application. Read [ktor's deployment documentation](https://ktor.io/docs/server-deployment.html) if you want to learn about different/right way of deploying a Ktor app.

In this setup `github actions` build and push the docker image to [`ghcr`](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry), and then
we trigger a new deployment on the server.


## Setting up the project
### Ktor Gradle Plugin
Configure [`ktor gradle plugin`](https://ktor.io/docs/server-fatjar.html), so we can build a `fatJar` using `gradlew fatJar` command.
```kts
plugins {
    id("io.ktor.plugin") version "3.0.1"
}

application {
    // https://ktor.io/docs/server-dependencies.html#create-entry-point
    mainClass.set("io.ktor.server.netty.EngineMain")
}

ktor {
    fatJar {
        // set the fatJar name here
        archiveFileName.set("server.jar")
    }
}
```

### Dockerfile
We will use a simple `Dockerfile` for our `runtime`. This `runtime image` requires us to build the `fatJar` externally before building our docker image. 


```dockerfile
FROM amazoncorretto:17
COPY build/libs/fat.jar /app/fat.jar
ENTRYPOINT ["java", "-jar", "/app/fat.jar"]
```


Create a Docker Compose configuration that includes our application and its database.
```yaml
services:
  ktor:
    container_name: ktor_app
    build: .
    ports:
      - "8080:8080"
    networks:
      - backend_network
    depends_on:
      - db
  db:
    image: postgres:16
    container_name: postgres_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: ktor_app_db
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_HOST: ${DB_HOST:-postgres}
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d ktor_app_db -u ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    networks:
      - backend_network

volumes:
  postgres_data:

networks:
  backend_network:
    driver: bridge
```
Your directory should look like this after these steps
```
.
├── Dockerfile
└── compose.yaml
```


### Github Action Setup
Create a [github workflow](https://docs.github.com/en/actions/writing-workflows/about-workflows) that deploys whenever new changes are merged into our `main` branch.
<Image src={githubActionImage} alt="A rocketship in space." class="max-w-[100%] mx-auto my-4"/>
```yaml
build-jar-file:
  runs-on: ubuntu-22.04
  steps:
    - name: Check out repository code
      uses: actions/checkout@v4

    - uses: actions/setup-java@v4
      with:
        distribution: 'oracle'
        java-version: '17'
        cache: 'gradle'
        cache-dependency-path: |
          **/.gradle*
          **/gradle-wrapper.properties

    - run:
        ./gradlew build

    - name: upload the jar file
      uses: actions/upload-artifact@v4
      with:
        name: statsify-jar
        path: build/libs/fat.jar
        overwrite: true

    - name: Build image
      run: docker build . --file Dockerfile --tag $IMAGE_NAME

    - name: Log in to registry
      run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    - name: Push image
      run: |
        IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$IMAGE_NAME
        docker tag $IMAGE_NAME $IMAGE_ID
        docker push $IMAGE_ID
```

## Final notes
* No rolling release: This setup stops the running application before deploying the new version.
* Add a script to trigger a deployment. Add github secrets.
